<img align="right" width="150px" src="https://github.com/Junjie1212/Linux-note/blob/main/doc/images/linux.jpg">

***Linux***

***目标：有较强的Linux下 troubleshooting 能力***

![linux](https://img.shields.io/badge/linux-centos_7.1-{}}.svg)
[![](https://img.shields.io/badge/blog-@junjie1212-{}.svg)](https://juejin.cn/user/215942747128382/columns)

- [______________________________________________________________________](#______________________________________________________________________)
- [▶︎︎︎Linux](#︎︎︎linux)
- [1. 命令基本格式及文件处理命令](#1-命令基本格式及文件处理命令)
  - [1.1 命令基本格式](#11-命令基本格式)
  - [1.2 文件处理命令(上)](#12-文件处理命令上)
  - [1.3 文件处理命令(下)](#13-文件处理命令下)
  - [1.4 常用目录的作用](#14-常用目录的作用)
  - [1.5 链接命令](#15-链接命令)
- [2. 文件搜索命令](#2-文件搜索命令)
  - [2.1 文件搜索命令locate](#21-文件搜索命令locate)
  - [2.2 命令搜索命令](#22-命令搜索命令)
  - [2.3 find命令](#23-find命令)
  - [2.4 grep命令](#24-grep命令)
- [3. 帮助命令](#3-帮助命令)
- [4. 压缩与解压命令](#4-压缩与解压命令)
  - [4.1 压缩与解压命令(上)](#41-压缩与解压命令上)
  - [4.2 压缩与解压命令(下)](#42-压缩与解压命令下)
- [5. 关机与重启命令](#5-关机与重启命令)
- [6. 挂载命令](#6-挂载命令)
- [______________________________________________________________________](#______________________________________________________________________-1)
- [▶︎︎︎Shell](#︎︎︎shell)
- [1. shell的概述](#1-shell的概述)
- [2. 脚本执行方式](#2-脚本执行方式)
- [3. 别名与快捷键](#3-别名与快捷键)
- [4. 历史命令](#4-历史命令)
- [5. 输出重定向](#5-输出重定向)
- [6. 管道符](#6-管道符)
  - [7.通配符](#7通配符)

# ______________________________________________________________________

# ▶︎︎︎Linux

# 1. 命令基本格式及文件处理命令

## 1.1 命令基本格式

1. 起始符：
   - [root@localhost ~]#
   - root 当前登录用户
   - localhost 主机名
   - ~ 当前所在目录（家目录）
   - \# 超级用户的提示符

2. ls命令选项：
    - ls -a 显示所有文件，包括隐藏文件
    * ls -l 显示详细信息
    * ls -d 查看目录属性
    * ls -h 人性化显示文件大小
    * ls -i 显示inode

3. 文件权限（10位），第一位为文件类型，后面每3位一组
   * -rw-r--r--
   * -文件类型（-文件 d目录 l软链接目录）
   * rw- u所有者
   * r-- g所属组
   * r-- o其他人
   * r读 w写 x执行

>       -rw-r--r--. 1 root root 1207
>           .代表ACL权限 1应用计数
>            在linux中“.”开头的文件是隐藏文件。

4. \# 超级用户的提示符 ￥普通用户的提示符 ~ 代表当前目录

## 1.2 文件处理命令(上)

1. linux中一切皆文件，Linux中普通文件用来保存数据，目录文件用来保存普通文件。
   
2. mkdir ：建立目录（make directories）
   - mkdir -p [目录名]
     - -p ：递归创建，当创建多级目录时需加
   - 例 mkdir light
   - 例 mkdir -p imooc/linux/light

3. cd [目录] ：切换目录（change directory）
   - cd ~/ cd  ：进入当前用户的家目录
   - cd - ：进入上次目录
   - cd .. ：进入上一级目录
   - cd . ：进入当前目录
    
4. 路径
   - 相对路径：参照当前所在目录，进行查找
   - 绝对路径：从根目录开始制定，一级一级递归，进行查找

5. pwd ：查询所在目录位置（print working directory）

6. 双击Tab键补命令/目录
   
7. pwd == print working directory<br>

## 1.3 文件处理命令(下)

1. 删除空目录
   - rmdir [目录名] （remove empty directories）   只能删除空目录

2. 删除文件或目录
   - rm -rf [文件或目录] （remove）
     - 选项 -r ：删除目录
     - 选项 -f ：强制
     - rm [文件名] ：提示是否删除
     - rm -r [目录] ：删除目录需加 -r ，目录中含有子文件，将持续询问是否删除
     - rm -rf [目录] ：删除目录， 不会询问是否删除而直接进行
     - 纯字符界面没有回收站。注意自杀指令：rm -rf /
   - 例 rm -rf /tmp/* ：删除tmp目录下的内容
   - 例 rm -rf /tmp/  ：删除tmp目录

3. 建议：删除文件或目录习惯使用命令 rm -rf [文件或目录]

4. 复制命令
   - cp [选项] [原文件或目录] [目标目录] （copy）
     - 选项 -r ：复制目录
     - 选项 -p ：连带文件属性复制
     - 选项 -d ：若原文件是链接文件，则复制链接属性
     - 选项 -a ：相当于 -pdr 全选
   - 例子
     - cp abc /tmp/ 若目标目录不加文件名，则为原名复制
     - cp abc /tmp/ana 若目标目录后加入文件名，则为改名复制
     - cp -r japan/ /tmp/ 复制目录
     - cp -a japan/ /tmp/ 完全复制，包括所有属性
   - 被复制文件的时间为执行复制命令的时间，若要使被复制的文件与原文件属性完全一致，需加 -a
  
5. 剪切或改名命令
   - mv [原文件或目录] [目标目录] （move）
     - mv japan/ /tmp/ 剪切目录时不需加 -r
     - mv abc longls 当原文件与目标目录，在同一目录下，则为改名命令

6. 当前系统时间命令：date

7. ls -l 命令别名 ：ll


## 1.4 常用目录的作用

> linux 是个严谨的操作系统，一级目录都严格规定
> 
> 做练习推荐在家目录中（root或home），以及tmp

1. / 根目录

2. /bin 命令保存目录（普通用户就可以读取的命令）
   - 根目录下的bin和sbin，usr目录下的bin和sbin，这四个目录都是用来保存系统命令。
   - bin目录下的命令任何用户都可以执行，sbin目录下只有root才可以执行。linux使用此方式来区分用户权限。

3. /boot 启动目录，启动相关文件

4. /dev 设备文件保存目录

5. /etc 配置文件保存目录

6. /home 普通用户的家目录

7. /lib 系统库保存目录
   
>          操作系统中并没有把所有功能都写入linux中，而将常用的功能写成一个个程序库
>          此些库保存在lib中，当需要时调用即可。避免全部写入linux中，使其无比庞大且运行缓慢。

8. /mnt 系统挂载U盘、移动硬盘目录

9. /media 挂载光盘目录

10. /misc 外接磁带机挂载目录

11. /root 超级用户的家目录

12. /tmp 临时目录
    - 可存放临时数据

13. /sbin 命令保存目录（超级用户才能使用的目录）

14. /proc 直接写入内存的

>          该目录同sys目录不能直接操作，这两个目录保存的是内存的挂载点。
>          其中的数据直接写在内存中。避免数据丢失或由于内存溢出导致系统崩溃。

15. /sys 

16. /usr 系统软件资源目录
    - /usr/bin/ 系统命令（普通用户）
    - /usr/sbin/ 系统命令（超级用户）

17. /var 系统相关文档内容


## 1.5 链接命令

> ln -s [原文件] [目标文件] （link）

   - 功能描述：生成链接文件
   - 选项 -s 创建软链接
   - 硬链接特征
     - 拥有相同的i节点和存储block块，可以看做是同一个文件。在格式化时，第一将分区划分为等大小的block数据块，该数据块通常为4KB。第二建立分区表，并为每个文件建立一个相关数据。当用户搜索某个文件时，会先到分区表中查找文件对应的block存储位置，接着到相应位置取出，并返回给用户。）硬链接与原文件拥有相同的i节点。与原文件非常相似。 当删除原文件或硬链接文件的任何一文件，不影响文件索引操作。可看做，同一个文件的不通进入点。它是同样的存储空间。

     - 可通过i节点识别
     - 不能跨分区建立
     - 不能针对目录使用，只有文件才可以创建
     - ln ./source/abc ./target/bcd.hard  创建后，引用计数+1
     - ls -i ./source/abc ./target/bcd.hard 可使用ls -i 来查看文件i节点号 
     - 不建议创建硬链接文件
     - 文件太过隐蔽，除了有i节点这样一个标识之外，很难区分它是不是硬链接
     - 硬链接限制较多，不能跨分区，不能针对目录，使用当中容易出现错误使用方法
   
   - 软链接特征
     - 类似于Windows快捷方式
     - 软链接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据。（拥有自己的分区表中索引数据,通过索引找到分区表中文件的目标索引数据，再通过目标索引数据，查找数据）
     - lrwxrwxrwx  l软链接， 软链接文件权限都为rwxrwxrwx, 虽然权限显示为777，但实际权限需要看原文件权限。
     - 修改任意文件，另一个都改变
     - 删除原文件，软链接不能使用
     - 创建软链接，原文件一定要写绝对路径。否则，软链接会到它所在的同一目录去找原文件。


# 2. 文件搜索命令

## 2.1 文件搜索命令locate

1. locate 文件名
   - 在后台数据库中按文件名搜索，搜索速度更快
   - 对于新建的文件，由于数据库没有更新，使用locate 不能查到。可以使用 updatedb强制更新数据库后即可查到。
   - 可使用 locate locate 搜索locate相关文件，可看到locate数据库。 
   - 在不同linux中，该数据库名字稍微不同，例如，locatedb、slocate、mlocate。

2. /var/lib/mlocate (保存的搜索数据库)
   - #locate 命令所搜索的后台数据库
   - 数据库不是实时的，更新频率大概一天更新一次

3. updatedb 更新数据库

4. 缺点：只能按照文件名进行搜索，但常用。

5. 配置文件
   
>        touch /root/cangls
>        touch /tmp/cangls
>        updatedb
>        locate cangls
>        显示为 /root/cangls  只有一条，而/tmp下的cangls没有显示出来，原因在于locate搜索遵循配置文件       /etc/updatedb.conf, 在PRUNEPATHS 中配置了/tmp/目录不进行搜索。所以没有进行查找。
   
   - /etc/updatedb.conf 配置文件
     - PRUNE_BIND_MOUNTS = "yes"
     - #开启搜索限制，yes为后面三项都生效。no为 后面三项都不生效
     - PRUNEFS =# 搜索时，不搜索的文件系统
     - PRUNENAMES =# 搜索时，不搜索的文件类型
     - PRUNEPATHS =# 搜索时，不搜索的路径


## 2.2 命令搜索命令
1. 文件搜索命令：whereis (只能搜索系统命令，不能搜索自己凭空创建的普通文件)

2. whoami显示当前操作用户  //who am i 显示登录用户

3. whatis ls ls的作用
   - 选项：
     - -b:只查找可执行文件
     - -m:只查找帮助文件
   
3. 文件搜索命令：which（不仅能看到命令的路径，如果有别名，还能看到别名）

4. ls =‘ls --color=auto’（ls显示颜色，设置为自动）
   
5. whereis和which不能看到shell的默认命令（如：cd），只能看到外部安装的命令。
   
6. echo $PATH说明：类似于Windows中的环境变量，执行命令的时候都要在path定义的目录中去寻找

>       所以像ls这样的命令就可以不用加路径（/bin/ls）执行了<br>
>       如果自己写的脚本 在运行时不想要具体的目录 需要在path设置目录


## 2.3 find命令

1. find搜索（避免大范围的搜索，会非常浪费系统资源，建议不在直接在“/”目录下搜索）
   - 格式：find [搜索范围][搜索条件]；<br>
   - 例：find /home -name 文件名；<br>
> ***注意：find搜索默认是完全匹配***

2. 如果需要进行模糊查询，需要添加通配符，通配符有以下3种
   - “*”匹配任意字符
   - 例：find /home -name "*test*",$~~~$显示所有名字带test的文件；
   - 例：find /home -name "*"，$~~~~$home目录下的所有文件，包括隐藏文件。

3. “?”匹配任意一个字符，

4. “[]”匹配任意一个中括号内的字符
   - 例：find /home -name "test[12]"$~~~~~~~~~~~~~$显示test1和test2文件；
   - 例：find /home -name "[12]*"$~~~~~~~~~~~~~~~~~$显示以1和2开头的文件。
   - 组合使用：例：find /home -name "*[12]*，显示所有1和2结尾的文件

5. find 按文件时间来搜索
   - find /home -mtime +10 在home目录下，查找10天前修改的文件
   - find /home -mtime 10 在home目录下，查找10天前当天修改的文件
   - find /home -mtime -10 在home目录下，查找10天内修改的文件
     - atime 文件访问时间
     - ctime 改变文件属性
     - mtime 修改文件内容

6. find搜索
   - find /root -iname test 不区分要搜索的test大小写格式
   - find /root -user root 搜索root目录下的所有属于root用户的文件
   - find /root -nouser 没有所属者的文件
>              liunx中，每个文件都有所属者，如果没有，那么一般都是垃圾文件
>              但还是有特例的，比如内核产生的文件，就没有所属者，一般在proc和sys目录下
>              还有外来文件，也就是U盘拷入的文件也会忽略所有者。

7. find 目录 -size 文件大小
   - 注意：文件大小用小写k和大写M。
   - -a 表示and
   - -o 表示or
   - find /etc -size +20k -a -size -50k -exec ls -lh {} \;
   - exec {} \; 固定格式，表示直接对前面的搜索结果进行后面的命令处理


## 2.4 grep命令

1. 命令：grep [选项] 字符串 文件名（在文件当中匹配符合条件的字符串）
   - 选项：
     - -i：忽略大小写
     - -v：排除制定字符串
   - 例：grep "size" anaconda-ks.cfg，即搜索anaconda-ks.cfg文件中包含“size”的内容。

2. find命令与grep命令的区别
   - find：在系统中搜索符合条件的文件名，使用 通配符（完全）匹配。
   - grep：在文件当中搜索符合条件的字符串，使用 正则表达式 （包含）匹配。



# 3. 帮助命令
1. man + 命令名称，最常用的帮助命令,man是manual的缩写
   - 例如 man ls
   - 进入man命令里操作，q退出 ，输入：/ -d 搜索"-d"字符串，按n往下搜“-d”,shift+n 往上搜“-d”

2. man的级别：
   - man man, man ls,man -f password,man 1 password,whereis password,man -f null,man -f ifconfig
   - 1、查看命令的帮助 
   - 2、查看可被内核调用的函数的帮助
   - 3、查看函数和函数库的帮助
   - 4、查看特殊文件的帮助（主要是/dev目录下的文件）
   - 5、查看配置文件的帮助
   - 6、查看游戏的帮助
   - 7、查看其它杂项的帮助
   - 8、查看系统管理员可用命令的帮助
   - 9、查看和内核相关文件的帮助


3. 
   - man -f 命令 相当于 whatis 命令
   - man -k 命令 相当于 apropos 命令 搜索含有关键词“命令”的帮助文档

4. man（最主流的）,--help,help,info总共四种获取帮助的命令。
   - 命令 --help 获取选项帮助
   - 例：ls --help

5. help shell内部命令
   - 例:whereis可以用来判断一个命令是否是shell内部命令,ls在/bin/下面有可执行文件说明ls命令不是shell内部命令
   - cd命令在/bin/下面没有相应的可执行文件，所以是shell自带的命令.

6. info 命令
   - info里面内容十分繁琐，是关于命令的一个巨大的帮助文档，里面有各个版本对于此命令的说明。
   - -回车：进入带*号的说明
   - -u: 进入上层页面
   - -n: 进入下一个帮助小节
   - -p: 进入上一个帮助小节
   - -q: 退出


# 4. 压缩与解压命令

## 4.1 压缩与解压命令(上)
>压缩与解压缩<br>
>常用压缩格式：.zip .gz .bz2<br>
>常用压缩格式：.tar.gz .tar.bz2

1. .zip压/解缩
   
   - zip$~~~~$压缩文件名 源文件 $~$//压缩文件
   - zip -r 压缩目录名 源目录 $~$//压缩目录
   - .zip格式解压缩
   - unzip 压缩文件 //解压缩文件 
2. .gz格式压/解缩
   - gzip $~~~~$源文件  $~~~~~~~~~~~~~~~~~~$//压缩为.gz格式的压缩文件，源文件会消失
   - gzip -c 源文件 > 压缩文件 $~$//压缩为.gz格式，源文件保留
   - gzip -r 目录 $~~~~~~~~~~~~~~~~~~~~~$//压缩目录下所有子文件，但是不能压缩目录
   - gzip -d 压缩文件 $~~~~~~~~~~~~~$//解压缩文件
   - gunzip 压缩文件 $~~~~~~~~~~~~~$//解压缩文件 

3. bzip压/解缩
   - bzip2 源文件名 //压缩文件，源文件会消失
   - bzip2 -k 源文件 //压缩后保留源文件
   - *bzip不能压缩目录
   - bzip -d 压缩文件 //解压bzip2文件
   - bunbzip 压缩文件 //压缩文件

4. 打包命令tar
   - tar -cvf 打包文件名 源文件 $~~~~~~~~~$//压缩为tar格式
   - tar -zvcf 压缩包名.tar.gz 源文件 $~~$//压缩为.tar.gz格式
   - tar -jvcf 压缩包名.tar.bz2 源文件 $~$//压缩为.tar.bz2格式

5. 解压tar
   - tar -xvf 打包文件名 $~~~~~~~~~$//解压tar格式文件
   - tar -zxvf 压缩包名.tar.gz $~~$//解压.tar.gz格式文件
   - tar -jxvf 压缩包名.tar.bz2 $~$//解压.tar.bz2格式文件

6. 
   - -c：打包
   - -v：显示过程
   - -f：指定打包后的文件名
   - -x：解打包
   - -z：压缩为.tar.gz格式
   - -j：压缩为.tar.bz2格式

7. 其他用法
   - tar -jxvf 打包文件名 -C 绝对路径 //指定解压缩位置
   - tar -zcvf 绝对路径（/tmp/）+打包文件名 源文件 源文件 //将多个文件解压到指定路径
   - tar -ztvf 压缩包文件名 //查看压缩包内文件


## 4.2 压缩与解压命令(下)
1. 打包压缩与解压缩
   - tar -cvf 打包文件名 源文件
   - 选项：
     - -c：打包
     - -v：显示过程
     - -f：指定打包后的文件名
   - 例 tar -cvf longzls.tar longzls

2. tar -xvf 打包文件名
   - 选项：-x：解打包
   - 例 tar -xvf longzls.tar

3. tar -zcvf 压缩包名.tar.gz 源文件
   - 选项：-z：压缩为.tar.gz

4. tar -zxvf 压缩包名.tar.gz
   - 选项：-x：加压缩.tar.gz格式

5. tar -jcvf 压缩包名.tar.bz2 源文件
   - 选项：-j：压缩为.tar.bz2

6. tar -jxvf 压缩包名.tar.bz2
   - 选项：-x：加压缩.tar.bz2格式

7. tar -jxvf jp.tar.bz2 -C /tmp/
   - 解压缩到指定目录，只能放在后面

8. tar -ztvf test.tar.gz
   - 不解压，查看压缩包的内容


# 5. 关机与重启命令
- shutdown [选项] 时间
  - -h 关机 -r 重启 -c 取消全一个关机命令 
  - shutdown -r now //立马重启
- halt poweroff inti 0 
  - 也都可以关机 但不安全
- reboot init 6 
  - 重启
- runlevel 
  - 查看运行级别 前级别 当前级别
- logout
  - 退出当前用户，也就是注销
- shutdown命令:
  - [shutdown -h 05:30] 设定凌晨05:30关机
  - [shutdown -h now] 立即关机
  - [shutdown -r 05:30] 设定凌晨05:30重启
  - [shutdown -r now] 立即重启
  - [shutdown -c] 取消前一个关机或重启命令


> ***注意***<br>
>- 以上定时关机或重启命令执行后，计算机就会卡在那里，当前用户和其他登录的用户都将无法操作，直到关机或重启<br>
>- 这个时候当前用户按【ctrl+c】可以取消本次关机或重启的操作，而其他用户如果按【ctrl+c】的话，则不会取消关机或重启操作，但可以退出中断，继续进行其他操作。<br>
<br>
> - 如果想要关机命令后台运行的话，可以在命令后面输入&，例如：【shutdown -h 05:30 &】，这样当前用户和其他登录用户的前台就不会中断了（若中断的话，按一下回车即可）<br>
<br>
> - 任何时候，不管哪个用户输入【shutdown -c】命令都可以取消关机或重启操作。<br>
<br>
> - 后面的时间可以使用【+m】格式，表示多少分钟后执行。也可以使用【hh:mm】格式，表示指定的时间执行，该时间是24小时制的；<br>
 <br>
> - 若远程登录的话，最后不要执行关机命令，因为开机需要到机房开机才行。重启也尽量少执行，若必须运行，则应关闭正在运行的服务；


# 6. 挂载命令
> 挂载命令(可理解为分配盘符)

1. 查询与自动挂载 
   - mount 查询系统中已挂载的设备
   - mount -a 依据配置文件/etc/fstab的内容，自动挂载

2. 挂载命令的格式
   - mount [-t 文件系统] [-o特殊选项] 设备 文件名 挂载点
   - 选项：
       - -t 文件系统：加入文件系统类型来指定挂载的类型，ext3,ext4,iso9660等文件系统
       - -o 特殊选项：可以指定挂载的额外选项
   - 例 mount -o remount,noexec /home/

3. 重新挂载/home分区，使用noexec权限
>        cd /home<br>
>        vi hello.sh<br>
>        #########################<br>
>        #!/bin/bash .sh脚本文件开头<br>
>        echo "Hello world!"<br>
>        #########################<br>
>        chmod 755 hello.sh 赋予执行权限<br>
>        ./hello.sh<br>
>        mount -o remount,exec /home/<br>

4. 挂载光盘
   - mkdir /mnt/cdrom/ #建立挂载点,空目录都可以
   - mount -t iso9660 /dev/sr0 /mnt/cdrom/ 
   - mount /dev/sr0 /mnt/cdrom/ #挂载光盘

5. 卸载光盘
   - umount 设备文件名或挂载点
   - umount /mnt/cdrom/或umount /dev/sr0

6. 挂载优盘
   - fdisk -l
   - #查看设备文件名
   - mount -t vfat /dev/sdb1 /mnt/usb/ 
   - #vfat指的是fat32文件系统
   - #Linux默认不支持NTFS文件系统的

# ______________________________________________________________________

# ▶︎︎︎Shell

# 1. shell的概述

1. Shell是什么
>         Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至时编写一些程序    
>         Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令

2. Shell分类
   - Bourne Shell：主文件名为sh
   - C Shell:BSD版的Unix
   - 两种语法类型有Bourne和C，彼此不兼容。
     - Bourne家族主要包括sh,ksh,Bash(Linux标准Shell),psh,zsh;
     - C家族主要包括：csh,tcsh
   - echo $SHELL 查看Shell
   - Bash：Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell
   - vi /etc/shells


# 2. 脚本执行方式

1. echo输出命令和脚本执行
   - 格式：echo [选项] [输出内容]
   - 选项： -e：支持反斜线控制的字符转换
      -echo "bols he cangls ni xihuan nayige"

2. 
   - \a - 输出警告音
   - \b - 退格符
   - \n - 换行符
   - \r - 回车键
   - \t - 制表符，也就是tab键
   - \v - 垂直制表符
   - \0nnn - 按照八进制ASCII码输出字符
   - \xhh - 按照十六进制ASCII表输出字符
     - echo -e "bols he cangls ni\b xihuan nayige"
     - echo -e "hell\bo"
     - echo -e "h\te\tl\nl\to\t"
     - echo -e "\x68\t\x65\t\x6c\n\x6c\t\x6f"
     - echo -e "\e[1;31m嫁人就要嫁凤姐\e[0m"
3. 输出颜色 
   - \e[1;##m 
     - 开启颜色显示； 
   - \e[0m   
     - 关闭颜色显示
   
   - #30m=黑色，31m=红色，32m=绿色，33m=黄色, #34m=蓝色，35m=洋红，36m=青色，37m=白色

4. 脚本执行：
   - 方法1：赋予执行权限，直接运行
     - chmod 755 hello.sh
     - ./hello.sh（或者绝对路径执行 /root/hello.sh）
   - 方法2：通过Bash调用执行脚本
     - bash hello.sh
5. #！/bin/Bash
   - 不是注释，它标称下面的内容是linux的标准脚本程序
   - 如果该脚本使用纯shell语句完成，不加#！/bin/Bash，运行没问题,但是脚本调用了其他语言，就会报错


# 3. 别名与快捷键
>Bash的基本功能

1. 使用别名
   - alias--查看系统当中默认已经生效的别名
   - alias ls = 'ls --color=never'--设定别名（临时生效,重启或重登录后失效）

2. 永久有效
   - vi ~/.bashrc（不止一个环境变量文件） 
     - 写入环境变量配置文件（用来更新用户环境变量~代表用户家目录）
   - vi /root/.bashrc 
     - 增加alias ls = 'ls --color=never’（系统再次重启后永久生效）
   - source .bashrc
     - 使当前环境变量设置生效（不需要系统再次重启后永久生效）
   - unalias ls 
     - 删除别名

3. 命令生效顺序
   - 第一顺位执行绝对路径或者相对路径的命令
   - 第二顺位执行别名
   - 第三顺位执行Bash的内部命令
   - 第四顺位执行按照$PATH环境变量设置定义的目录顺序的第一个命令

4. 快捷键
   - ctrl + c 强制终止
   - ctrl + l 清屏相当于clear
   - ctrl + a 光标快速回到行首
   - ctrl + e 光标快速去到行尾
   - ctrl + u 从光标所在位置删除到行首
   - ctrl + z 把命令放入后台--这个命令很谨慎使用
   - ctrl + r 历史命令搜索

# 4. 历史命令
1. history [选项] [历史命令保存文件]
   - -c 清空历史命令
   - -w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history

2. vi /etc/profile 环境变量配置文件
   - 默认保存1000条
   - HISTSIZE=1000

3. 调用历史命令
   - 上下箭头来重复调用
   - !n 来执行第n条历史命令
   - !! 重复执行上一条命令
   - !字符串 重复执行后一个该串开头的命令

4. Tab键
   - 进行命令(环境变量)和目录补全(操作路径)


# 5. 输出重定向
1. 
   - 标准输入设备：
     - 键盘/dev/stdin 
     - 描述0 
   - 标准输出：
     - 显示器/dev/stdout 
     - 描述1 
   - 标准错误输出：
     - 显示器/dev/stderr 
     - 描述2

2. 输出重定向
   - 命令 > 文件 
     - 覆盖方式把命令的正确输出 输出到指定文件或设备中
   - 命令 >> 文件 
     - 追加方式把命令的正确输出 输出到指定文件或设备中  //>左右有空格
   - 错误命令 2>（2>>）文件 
     - 覆盖（追加）方式把命令的错误输出 输出到指定文件或设备中  //错误输出>>左右不能有空格
   - 命令 >(>>) 文件 2>&1  
     - 覆盖（追加）方式把命令的正确输出 输出到指定文件或设备中
   - 命令 &>（&>>）文件 
     - 覆盖（追加）方式把命令的正确输出 输出到指定文件或设备中
   - 命令 >>文件1 2>>文件2  
     - 把正确的输出追加到文件1中，把错误的输出追加到文件2中
   - 命令 &> /dev/null 
     - 将命令的结果丢入null（作用类似于垃圾箱）中 只执行，不显示

3. 输入重定向(用的少，了解即可)
   - wc 
     - 执行后 输入 ctrl+d结束 会统计输入行数 单词数 字母数
   - wc [选项] [文件名] -c字节数 -l行数 -w单词数
   - wc < 文件名 
     - 用文件的内容作为输入 wc << 标记 统计标记到标记再次出现之间的字符


# 6. 管道符
1. ";"连接命令 顺序执行

2. "&&"连接命令 逻辑与执行 第一条执行 第二条执行 第一条错误 第二条不执行

3. "||"连接命令 逻辑或执行 第一条执行 第二条不执行 第一条错误 第二条执行

4. 脚本中的应用：命令 && echo yes || echo no 命令正确yes 错误no
>        注意&& echo yes || echo no 顺序不能颠倒，不然命令出错的时候会同时输出no yes

5. more [文件名] "分页显示文件内容"

6. "|" 管道符 命令1|命令2 命令1正确的结果 作为命令2的操作对象
   - 例 ls -l > /etc/ | more “用于分页显示命令执行结果”
   - netstat -an | grep ESTABLISHED | wc -l "用于查看当前连接本机的客户端 并 统计客户端数量"

# 7.通配符
1. 通配符（文件名或者目录名）
   - ?  匹配任意一个字符
   - *  匹配0个或任意多个字符
   - [] 匹配括号中任意一个字符
   - [-]匹配括号中任意一个字符,-代表一个范围
   - [^]匹配不是括号中任意一个字符

2. Bash中其他特殊符号
   - '' 单引号，在单引号中左右的特殊符号，如$,&都没有特殊含义
   - "" 双引号，在双引号中左右的特殊符号都没有特殊含义
     - 但是“$”,"`","\"是例外。拥有“调用变量的值”，“引用命令”和“转义符”的特殊含义
   - `` 反引号，反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样。
   - $() 用来引用系统命令
   - 在Shell脚本中，#开头的行代表注释
   - $ 用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值
   - \ 转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。如\$将输出"$"符号
